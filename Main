'''
File: main.py
Description: This file is the program of Assignment Part 2:Implementation, it realizes the operation of a game character Alchemy in the game, the role can drink medicine and refine medicine. After drinking a certain potion, its own properties change.
Author: Enda Yu
StudentID: 1103942071
EmailID: Yuyey004
This is my own work as defined by the University's Academic Misconduct Policy.
'''

from abc import ABC, abstractmethod

class Reagent(ABC):
    def __init__(self, name: str, potency: float) -> None:
        self.name = name
        self.potency = potency
    @abstractmethod
    def refine(self) -> None:
        pass
    def getName(self) -> str:
        return self.name
    def getPotency(self) -> float:
        return self.potency
    def setPotency(self, potency: float) -> None:
        self.potency = potency

class Herb(Reagent):
    def __init__(self, name: str, potency: float, grimy: bool = True) -> None:
        super().__init__(name, potency)
        self.grimy = grimy
    def refine(self) -> str:
        """
        Herb: Refining leads to a herb that is not grimy and will multiply its existing potency by 2.5. It will print this information on the screen as well.
        """
        self.setGrimy(False)
        self.setPotency(round(self.getPotency()*2.5, 2))
        return "Refined success! The potency is {} now.".format(self.getPotency())
    def getGrimy(self) -> bool:
        return self.grimy
    def setGrimy(self, grimy: bool) -> bool:
        self.grimy = grimy
        return True

class Catalyst(Reagent):
    def __init__(self, name: str, potency: float, quality: float) -> None:
        super().__init__(name, potency)
        self.quality = quality
    def refine(self) -> str:
        """
        Catalyst: If the quality of the catalyst is below 8.9 then its quality will be increased by 1.1 and this information is printed on the screen. If its quality is equal or above 8.9 then its quality is set to 10. 
        It should print on the screen the quality and say that “it cannot be refined any further”.
        """
        if self.getQuality() >= 10:
            return "The quality is 10 now, it cannot be refined any further"
        if self.getQuality() >= 8.9:
            self.quality = 10.0
            return "Refined success! The quality is 10 now, it cannot be refined any further"
        self.quality = round(self.getQuality() + 1.1, 2)
        return "Refined success! The quality is {} now.".format(self.getQuality())
    def getQuality(self) -> float:
        return self.quality

class Potion(ABC):
    def __init__(self, name: str, stat: str, boost: float) -> None:
        self.name = name
        self.stat = stat
        self.boost = boost
    @abstractmethod
    def calculateBoost(self) -> None:
        pass
    def getName(self) -> str:
        return self.name
    def getStat(self) -> str:
        return self.stat
    def getBoost(self) -> float:
        return self.boost
    def setBoost(self, boost: float) -> None:
        self.boost = boost

class SuperPotion(Potion):
    def __init__(self, name: str, stat: str, herb: Herb, catalyst: Catalyst) -> None:
        self.herb = herb
        self.catalyst = catalyst
        super().__init__(name, stat, self.calculateBoost())
    def calculateBoost(self) -> float:
        """
        Super potion: potency of its herb + (potency of its catalyst * quality of its catalyst) * 1.5. The result should be rounded by 2 decimals.
        """
        herb = self.getHerb()
        catalyst = self.getCatalyst()
        return round(herb.getPotency() + catalyst.getPotency()*catalyst.getQuality()*1.5, 2)
    def getHerb(self) -> Herb:
        return self.herb
    def getCatalyst(self) -> Catalyst:
        return self.catalyst

class ExtremePotion(Potion):
    def __init__(self, name: str, stat: str, reagent: Reagent, potion: Potion) -> None:
        self.reagent = reagent
        self.potion = potion
        super().__init__(name, stat, self.calculateBoost())
    def calculateBoost(self) -> float:
        """
        Extreme potion: (potency of its reagent * boost value of its super potion) * 3.0. The result should be rounded by two decimals.
        """
        reagent = self.getReagent()
        potion = self.getPotion()
        return round(reagent.getPotency()*potion.getBoost()*3.0, 2)
    def getReagent(self) -> Reagent:
        return self.reagent
    def getPotion(self) -> Potion:
        return self.potion

class Laboratory:
    def __init__(self, potions: list, herbs: list, catalysts: list) -> None:
        self.potions = potions
        self.herbs = herbs
        self.catalysts = catalysts
    def mixPotion(self, name: str, type: str, stat: str, primaryIngredient: str, secondaryIngredient: str) -> None:
        # Find all ingredients.
        pri, prilist = self.findIngredient(primaryIngredient)
        sec, seclist = self.findIngredient(secondaryIngredient)
        # if pri is None or sec is None:
        if pri is None or sec is None:
            raise ValueError("Mix failed: Ingredients are not enough!")

        if type == "SuperPotion":
            potion = SuperPotion(name, stat, pri, sec)
        elif type == "ExtremePotion":
            potion = ExtremePotion(name, stat, pri, sec)
        else:
            raise ValueError("Mix failed: Type should be SuperPotion or ExtremePotion")
        self.potions.append(potion)

        # Remove the ingredients from the storage.
        prilist.remove(pri)
        seclist.remove(sec)

    def addReagent(self, reagent: Reagent, amount: int) -> None:
        if amount < 0:
            raise ValueError("The amount should be positive integer.")
        if isinstance(reagent, Herb):
            old = reagent
            for _ in range(amount):
                herb = Herb(old.getName(), old.getPotency(), old.getGrimy())
                self.herbs.append(herb)
        if isinstance(reagent, Catalyst):
            old = reagent
            for _ in range(amount):
                catalyst = Catalyst(old.getName(), old.getPotency(), old.getQuality())
                self.catalysts.append(catalyst)

    def getPotionNum(self, name: str) -> int:
        num = 0
        for item in self.potions:
            if item.getName() == name:
                num += 1
        return num

    def getHerbNum(self, name: str) -> int:
        num = 0
        for item in self.herbs:
            if item.getName() == name:
                num += 1
        return num
    def getCatalystNum(self, name: str) -> int:
        num = 0
        for item in self.catalysts:
            if item.getName() == name:
                num += 1
        return num

    def findIngredient(self, name: str):
        ingredient = self.__findIngredient(name, self.potions)
        if ingredient is not None:
            return ingredient, self.potions

        ingredient = self.__findIngredient(name, self.herbs)
        if ingredient is not None:
            return ingredient, self.herbs
        
        ingredient = self.__findIngredient(name, self.catalysts)
        if ingredient is not None:
            return ingredient, self.catalysts
        return None, []
    def __findIngredient(self, name: str, lst: list):
        for item in lst:
            if item.getName() == name:
                return item
        return None
    def removePotion(self, potion: Potion) -> bool:
        if potion not in self.potions:
            return False
        self.potions.remove(potion)
        return True
    def refineAll(self):
        """
        Refine all herbs and catalysts.
        """
        for item in self.herbs:
            item.refine()
        for item in self.catalysts:
            item.refine()

class Alchemist:
    def __init__(self, attack: int, strength: int, defense: int,
        magic: int, ranged: int, necromancy: int,
        laboratory: Laboratory,
        recipes: dict = {
            "Super Attack": ["Super Attack", "SuperPotion", "attack", "Irit", "Eye of Newt"],
            "Super Strength": ["Super Strength", "SuperPotion", "strength", "Kwuarm", "Limpwurt Root"],
            "Super Defence": ["Super Defence", "SuperPotion", "defence", "Cadantine", "White Berries"],
            "Super Magic": ["Super Magic", "SuperPotion","magic", "Lantadyme", "Potato Cactus"],
            "Super Ranging": ["Super Ranging", "SuperPotion", "ranged", "Dwarf Weed", "Wine of Zamorak"],
            "Super Necromancy": ["Super Necromancy", "SuperPotion", "necromancy", "Arbuck", "Blood of Orcus"],
            "Extreme Attack": ["Extreme Attack", "ExtremePotion", "attack", "Avantoe", "Super Attack"],
            "Extreme Strength": ["Extreme Strength", "ExtremePotion", "strength","Dwarf Weed", "Super Strength"],
            "Extreme Defence": ["Extreme Defence", "ExtremePotion", "defence", "Lantadyme", "Super Defence"],
            "Extreme Magic": ["Extreme Magic", "ExtremePotion", "magic", "Ground Mud Rune", "Super Magic"],
            "Extreme Ranging": ["Extreme Ranging", "ExtremePotion", "ranged", "Grenwall Spike", "Super Ranging"],
            "Extreme Necromancy": ["Extreme Necromancy", "ExtremePotion", "necromancy", "Ground Miasma Rune", "Super Necromancy"]
        }) -> None:
        if False == self.checkAttibuteValues(attack, strength, defense, magic, ranged, necromancy):
            raise TypeError("All the attributes should be integers from 0 to 100.")

        self.attack = attack
        self.strength = strength
        self.defense = defense
        self.magic = magic
        self.ranged = ranged
        self.necromancy = necromancy
        self.laboratory = laboratory
        self.recipes = recipes

        # I added the following as an extra:
        # In general, potions drunk in the game will have a certain duration, not permanent.
        # This property records the change in value caused by the potion currently drunk.
        # The mage's actual stat is its own plus the BUFF from the current potions.
        # The original attribute of the wizard is an int, which can be a float after it has been superimposed.
        self.buffs = {
            "attack": 0,
            "strength": 0,
            "defense": 0,
            "magic": 0,
            "ranged": 0,
            "necromancy": 0,
        }

    def checkAttibuteValues(self, attack, strength, defense, magic, ranged, necromancy) -> bool:
        if (attack < 0 or attack > 100) \
            or (strength < 0 or strength > 100) \
            or (defense < 0 or defense > 100) \
            or (magic < 0 or magic > 100) \
            or (ranged < 0 or ranged > 100) \
            or (necromancy < 0 or necromancy > 100):
            return False
        return True

    def getLaboratory(self) -> Laboratory:
        return self.laboratory
    def getRecipes(self) -> dict:
        return self.recipes
    def mixPotion(self, recipe:str) -> None:
        if recipe not in self.recipes:
            raise ValueError("Could not found recipe of {}".format(recipe))
        # Read the recipe and mix it.
        name, recipeType , stat, pri, sec = self.recipes.get(recipe)
        self.laboratory.mixPotion(name, recipeType, stat, pri, sec)
    def drinkPotion(self, potion: Potion) -> str:
        if False == self.laboratory.removePotion(potion):
            raise ValueError("Could not found potion.")
        stat = potion.getStat()
        self.buffs[stat] += round(potion.getBoost(), 2)
        return "{} increased {}".format(stat, potion.getBoost())

    def collectReagent(self, reagent:Reagent, amount: int) -> None:
        self.laboratory.addReagent(reagent, amount)
    def refineReagents(self):
        self.laboratory.refineAll()
    def getPotion(self, name: str) -> Potion:
        potion, _ = self.laboratory.findIngredient(name)
        return potion
    def getAttack(self) -> float:
        return round(self.buffs["attack"] + self.attack, 2)
    def getStrength(self) -> float:
        return round(self.buffs["strength"] + self.strength, 2)
    def getDefense(self) -> float:
        return round(self.buffs["defense"] + self.defense, 2)
    def getMagic(self) -> float:
        return round(self.buffs["magic"] + self.magic, 2)
    def getRanged(self) -> float:
        return round(self.buffs["ranged"] + self.ranged, 2)
    def getNecromancy(self) -> float:
        return round(self.buffs["necromancy"] + self.necromancy, 2)





